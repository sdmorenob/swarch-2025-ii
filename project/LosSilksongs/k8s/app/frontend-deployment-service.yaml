apiVersion: apps/v1
kind: Deployment
metadata:
  name: frontend
  namespace: musicshare
  labels:
    app: frontend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: frontend
  template:
    metadata:
      labels:
        app: frontend
    spec:
      # Anti-affinity para distribuir en diferentes nodos
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                labelSelector:
                  matchExpressions:
                    - key: app
                      operator: In
                      values:
                        - frontend
                topologyKey: kubernetes.io/hostname
      containers:
        - name: frontend
          image: us-central1-docker.pkg.dev/musicshare-480712/musicshare-docker/frontend
          imagePullPolicy: Always
          ports:
            - containerPort: 80
              name: http
          env:
            - name: NODE_ENV
              value: "production"
            - name: REACT_APP_API_GATEWAY
              value: "/api"
            - name: GRAPHQL_ENDPOINT
              value: "/graphql"
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 200m
              memory: 256Mi
          volumeMounts:
            - name: frontend-env
              mountPath: /usr/share/nginx/html/env-config.js
              subPath: env-config.js
          livenessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 10
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /
              port: 80
            initialDelaySeconds: 5
            periodSeconds: 5
      volumes:
        - name: frontend-env
          configMap:
            name: frontend-env-config
            items:
              - key: env-config.js
                path: env-config.js
---
# SSR music-upload (Next.js) - sirve la página /upload-music
apiVersion: apps/v1
kind: Deployment
metadata:
  name: music-upload
  namespace: musicshare
  labels:
    app: music-upload
spec:
  replicas: 1
  selector:
    matchLabels:
      app: music-upload
  template:
    metadata:
      labels:
        app: music-upload
    spec:
      containers:
        - name: music-upload
          image: us-central1-docker.pkg.dev/musicshare-480712/musicshare-docker/music-upload:latest
          imagePullPolicy: Always
          ports:
            - containerPort: 3000
              name: http
          env:
            - name: NODE_ENV
              value: "production"
            - name: PORT
              value: "3000"
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 200m
              memory: 256Mi
          livenessProbe:
            httpGet:
              path: /
              port: 3000
            initialDelaySeconds: 15
            periodSeconds: 15
          readinessProbe:
            httpGet:
              path: /
              port: 3000
            initialDelaySeconds: 10
            periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: music-upload
  namespace: musicshare
  labels:
    app: music-upload
spec:
  selector:
    app: music-upload
  ports:
    - protocol: TCP
      port: 3000
      targetPort: 3000
      name: http
  type: ClusterIP
---
apiVersion: v1
kind: Service
metadata:
  name: frontend
  namespace: musicshare
  labels:
    app: frontend
spec:
  selector:
    app: frontend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
      name: http
  type: ClusterIP
---
# Servicio tipo LoadBalancer para acceso público al Frontend
# Este es el punto de entrada principal para usuarios finales
apiVersion: v1
kind: Service
metadata:
  name: frontend-loadbalancer
  namespace: musicshare
  labels:
    app: frontend
  annotations:
    # AWS específico (si se usa EKS)
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "http"
    # Azure específico (si se usa AKS)
    service.beta.kubernetes.io/azure-load-balancer-internal: "false"
    # GCP específico (si se usa GKE)
    cloud.google.com/load-balancer-type: "External"
spec:
  selector:
    app: frontend
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
      name: http
  type: LoadBalancer
  externalTrafficPolicy: Local
  sessionAffinity: None
  healthCheckNodePort: 30000
---
# Volumenes para el frontend
apiVersion: v1
kind: ConfigMap
metadata:
  name: frontend-env-config
  namespace: musicshare
data:
  env-config.js: |
    // Generated by k8s ConfigMap - ensures runtime endpoint is correct
    window._env_ = {
      REACT_APP_MUSICSHARE_BACKEND_URL: "/graphql",
      REACT_APP_MUSICSHARE_BACKEND_AUTH_TOKEN_DEV: "",
    };
    window.__ENV__ = {
      GRAPHQL_ENDPOINT: "/graphql"
    };

