# Este repositorio ha sido migrado a Kubernetes.
# Se han añadido manifiestos Kubernetes en el directorio `k8s/`.
#
# Arquitectura clave implementada:
# - `frontend` expuesto mediante un Service `type: LoadBalancer` (balanceador público).
# - `traefik-gateway` (API Gateway) desplegado como Deployment/Service interno (ClusterIP).
#   El balanceador público queda delante del frontend; el API Gateway se encarga del enrutado
#   hacia los microservicios y permanece dentro del cluster (estancias distintas).
# - Cada microservicio tiene su Deployment y Service (ClusterIP) con réplicas iniciales.
# - HorizontalPodAutoscaler (HPA) definido para escalado automático de instancias.
#
# Para desplegar en un clúster Kubernetes (por ejemplo minikube, kind o un proveedor cloud):
# 1. Crear el namespace y aplicar todos los manifiestos:
#
#    kubectl apply -f k8s/namespace.yaml
#    kubectl apply -f k8s/traefik-deployment.yaml
#    kubectl apply -f k8s/frontend-deployment-service.yaml
#    kubectl apply -f k8s/backend-deployments-services.yaml
#    kubectl apply -f k8s/databases.yaml
#    kubectl apply -f k8s/hpa.yaml
#
# 2. Verificar recursos:
#
#    kubectl get all -n musicshare
#    kubectl get hpa -n musicshare
#
# 3. Observaciones:
# - Las imágenes referenciadas en los manifiestos (`musicshare/<service>:latest`) deben existir en
#   un registro accesible desde el clúster (Docker Hub, GCR, Azure ACR, etc.). Para desarrollo local
#   con `minikube` use `minikube image load` o configure un registry.
# - El HPA requiere `metrics-server` instalado en el clúster para funcionar correctamente.
# - Los volúmenes de base de datos se han dejado como `emptyDir` en los manifiestos de ejemplo;
#   para producción sustituir por `PersistentVolumeClaim` y `StorageClass` adecuados.
#

## Nota
Este archivo `docker-compose.yml` se conserva como guía informativa; el despliegue objetivo en
Kubernetes se realiza con los manifiestos en `k8s/`.
